// Package v1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package v1

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	SWCookieAuthScopes = "SWCookieAuth.Scopes"
)

// Defines values for DisputeRoleDisputeRole.
const (
	Complainant             DisputeRoleDisputeRole = "complainant"
	GuiltyResponsiblePerson DisputeRoleDisputeRole = "guilty_responsible_person"
	GuiltyWorker            DisputeRoleDisputeRole = "guilty_worker"
	ResponsiblePerson       DisputeRoleDisputeRole = "responsible_person"
)

// Defines values for EntityStatus.
const (
	Any    EntityStatus = "any"
	Closed EntityStatus = "closed"
	InWork EntityStatus = "in_work"
	Opened EntityStatus = "opened"
)

// Claims defines model for Claims.
type Claims struct {
	EmployeeId     *int64 `json:"employee_id,omitempty"`
	OrganizationId string `json:"organization_id"`
	UserId         string `json:"user_id"`
	UserRole       string `gorm:"column:role" json:"user_role"`
}

// CloseDispute defines model for CloseDispute.
type CloseDispute struct {
	ClosedAt           string       `json:"closed_at"`
	GuiltyWorkerNames  []string     `gorm:"type:text[]" json:"guilty_worker_names"`
	IsShortageCanceled bool         `json:"is_shortage_canceled"`
	Status             EntityStatus `json:"status"`
}

// Correspondence defines model for Correspondence.
type Correspondence struct {
	AttachmentPath   *string   `json:"attachment_path,omitempty"`
	CorrespondenceId string    `json:"correspondence_id"`
	CreatedAt        time.Time `json:"created_at"`
	MessageBody      *string   `json:"message_body,omitempty"`
	RevisionId       string    `json:"revision_id"`
	SenderId         string    `json:"sender_id"`
}

// CreateDispute defines model for CreateDispute.
type CreateDispute struct {
	ClosedAt           *time.Time   `json:"closed_at,omitempty"`
	CreatedAt          time.Time    `json:"created_at"`
	DisputeId          string       `json:"dispute_id"`
	IsArbitrInvited    bool         `json:"is_arbitr_invited"`
	IsDisputeReopened  bool         `json:"is_dispute_reopened"`
	IsShortageCanceled bool         `json:"is_shortage_canceled"`
	OrganizationId     string       `json:"organization_id"`
	ReopenedAt         *time.Time   `json:"reopened_at,omitempty"`
	ShortageId         string       `json:"shortage_id"`
	Status             EntityStatus `json:"status"`
}

// CreateMsgResponse defines model for CreateMsgResponse.
type CreateMsgResponse struct {
	MessageId string `json:"message_id"`
}

// Dispute defines model for Dispute.
type Dispute struct {
	ClosedAt                    time.Time `json:"closed_at"`
	ComplainantName             string    `json:"complainant_name"`
	CreatedAt                   time.Time `json:"created_at"`
	CurrencyCode                string    `json:"currency_code"`
	DisputeId                   string    `json:"dispute_id"`
	GoodsId                     int       `json:"goods_id"`
	GuiltyResponsiblePersonName string    `json:"guilty_responsible_person_name"`
	GuiltyWorkerNames           []string  `gorm:"type:text[]" json:"guilty_worker_names"`
	IsShortageCanceled          bool      `json:"is_shortage_canceled"`
	LostAmount                  float64   `json:"lost_amount"`
	LostreasonVal               string    `json:"lostreason_val"`
	ResponsiblePersonName       string    `json:"responsible_person_name"`
	Status                      string    `json:"status"`
	TareId                      int       `json:"tare_id"`
	TareType                    string    `json:"tare_type"`
}

// DisputeChat defines model for DisputeChat.
type DisputeChat struct {
	AttachmentPath *string   `json:"attachment_path,omitempty"`
	CreatedAt      time.Time `json:"created_at"`
	DisputeId      string    `json:"dispute_id"`
	MessageBody    *string   `json:"message_body,omitempty"`
	MessageId      string    `json:"message_id"`
	SenderId       string    `json:"sender_id"`
}

// DisputeList defines model for DisputeList.
type DisputeList struct {
	ClosedAt              *string      `json:"closed_at,omitempty"`
	ComplainantEmployeeId string       `json:"complainant_employee_id"`
	ComplainantName       string       `json:"complainant_name"`
	CreatedAt             string       `json:"created_at"`
	CurrencyCode          int64        `json:"currency_code"`
	DisputeId             string       `json:"dispute_id"`
	GoodsId               int64        `json:"goods_id"`
	LostAmount            float32      `json:"lost_amount"`
	LostreasonVal         string       `json:"lostreason_val"`
	OrganizationTitle     string       `json:"organization_title"`
	ResponsiblePersonName *string      `json:"responsible_person_name,omitempty"`
	Status                EntityStatus `json:"status"`
	TareId                int64        `json:"tare_id"`
	TareType              string       `json:"tare_type"`
}

// DisputeRole defines model for DisputeRole.
type DisputeRole struct {
	CreatedAt   time.Time              `json:"created_at"`
	DisputeId   string                 `json:"dispute_id"`
	DisputeRole DisputeRoleDisputeRole `json:"dispute_role"`
	UserId      string                 `json:"user_id"`
}

// DisputeRoleDisputeRole defines model for DisputeRole.DisputeRole.
type DisputeRoleDisputeRole string

// EntityStatus defines model for EntityStatus.
type EntityStatus string

// Message defines model for Message.
type Message struct {
	AttachmentPath  *string   `json:"attachment_path,omitempty"`
	CreatedAt       time.Time `json:"created_at"`
	DisputeId       string    `json:"dispute_id"`
	MessageBody     *string   `json:"message_body,omitempty"`
	MessageId       string    `json:"message_id"`
	Role            string    `json:"role"`
	SenderAvatarUrl string    `json:"sender_avatar_url"`
	SenderId        string    `json:"sender_id"`
	SenderName      string    `json:"sender_name"`
}

// Organization defines model for Organization.
type Organization struct {
	InnerId           int64  `json:"inner_id"`
	OrganizationCode  string `json:"organization_code"`
	OrganizationId    string `json:"organization_id"`
	OrganizationTitle string `json:"organization_title"`
}

// Revision defines model for Revision.
type Revision struct {
	ClosedAt          *time.Time   `json:"closed_at,omitempty"`
	CreatedAt         time.Time    `json:"created_at"`
	DisputeId         string       `json:"dispute_id"`
	InWorkAt          *time.Time   `json:"in_work_at,omitempty"`
	OrganizationId    string       `json:"organization_id"`
	OrganizationTitle *string      `json:"organization_title,omitempty"`
	RevisionId        string       `json:"revision_id"`
	Status            EntityStatus `json:"status"`
	WorkerId          *string      `json:"worker_id,omitempty"`
	WorkerName        *string      `json:"worker_name,omitempty"`
}

// Shortage defines model for Shortage.
type Shortage struct {
	CreatedAt    time.Time `json:"created_at"`
	CurrencyCode string    `json:"currency_code"`
	GoodsId      int       `json:"goods_id"`
	IsDisputed   bool      `json:"is_disputed"`
	LostAmount   float64   `json:"lost_amount"`
	LostreasonId float32   `json:"lostreason_id"`
	ShortageId   string    `json:"shortage_id"`
	TareId       int       `json:"tare_id"`
	TareType     string    `json:"tare_type"`
	UserId       string    `json:"user_id"`
}

// TokenData defines model for TokenData.
type TokenData struct {
	Claims Claims `json:"claims"`
	Token  string `json:"token"`
	Ttl    int    `json:"ttl"`
}

// WbxAuthCodeCheckResponse defines model for WbxAuthCodeCheckResponse.
type WbxAuthCodeCheckResponse struct {
	Error  *string `json:"error,omitempty"`
	Result int     `json:"result"`
}

// GetDisputeV1Params defines parameters for GetDisputeV1.
type GetDisputeV1Params struct {
	DisputeId *string `form:"disputeId,omitempty" json:"disputeId,omitempty"`
	GoodsId   *int    `form:"goodsId,omitempty" json:"goodsId,omitempty"`
}

// CreateDisputeV1MultipartBody defines parameters for CreateDisputeV1.
type CreateDisputeV1MultipartBody struct {
	File           *openapi_types.File `json:"file,omitempty"`
	MessageBody    string              `json:"message_body"`
	OrganizationId string              `json:"organization_id"`
	ShortageId     string              `json:"shortage_id"`
}

// CloseDisputeV1JSONBody defines parameters for CloseDisputeV1.
type CloseDisputeV1JSONBody struct {
	DisputeId       string    `json:"dispute_id"`
	GuiltyWorkerIds *[]string `json:"guilty_worker_ids,omitempty"`
}

// GetDisputesV1Params defines parameters for GetDisputesV1.
type GetDisputesV1Params struct {
	// Offset Смещение с которого необходимо получить споры
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Количество возращаемых споров
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Status Статус возвращаемых споров
	Status *EntityStatus `form:"status,omitempty" json:"status,omitempty"`
}

// CreateMessageV1MultipartBody defines parameters for CreateMessageV1.
type CreateMessageV1MultipartBody struct {
	DisputeId   string              `json:"dispute_id"`
	File        *openapi_types.File `json:"file,omitempty"`
	MessageBody *string             `json:"message_body,omitempty"`
}

// GetMessagesV1Params defines parameters for GetMessagesV1.
type GetMessagesV1Params struct {
	// Offset Смещение с которого необходимо получить сообщения
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Количество возращаемых сообщений
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// DisputeId ID спора, по которому нужно найти сообщения
	DisputeId string `form:"disputeId" json:"disputeId"`
}

// GetOrganizationsV1Params defines parameters for GetOrganizationsV1.
type GetOrganizationsV1Params struct {
	// OrganizationCode Тип организации по которому осущствляется поиск
	OrganizationCode *string `form:"organizationCode,omitempty" json:"organizationCode,omitempty"`

	// Offset Смещение с которого необходимо получить организации
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Количество возращаемых организаций
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// SearchToken Токен поиска
	SearchToken *string `form:"searchToken,omitempty" json:"searchToken,omitempty"`
}

// GetRevisionV1Params defines parameters for GetRevisionV1.
type GetRevisionV1Params struct {
	RevisionId string `form:"revisionId" json:"revisionId"`
}

// CreateRevisionV1MultipartBody defines parameters for CreateRevisionV1.
type CreateRevisionV1MultipartBody struct {
	DisputeId      string              `json:"dispute_id"`
	File           *openapi_types.File `json:"file,omitempty"`
	MessageBody    string              `json:"message_body"`
	OrganizationId string              `json:"organization_id"`
}

// GetCorrespondencesV1Params defines parameters for GetCorrespondencesV1.
type GetCorrespondencesV1Params struct {
	RevisionId string `form:"revision_id" json:"revision_id"`
	Offset     *int   `form:"offset,omitempty" json:"offset,omitempty"`
	Limit      *int   `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetRevisionsV1Params defines parameters for GetRevisionsV1.
type GetRevisionsV1Params struct {
	// DisputeId ID Спора для которого необходимо получить ревизии (если указан и disputeId, и status, то выборка осуществляется по disputeId)
	DisputeId *string `form:"disputeId,omitempty" json:"disputeId,omitempty"`

	// Offset Смещение с которого необходимо получить ревизии
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Количество возращаемых ревизий
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Status Статус возвращаемых ревизий (если указан и disputeId, и status, то выборка осуществляется по disputeId)
	Status *EntityStatus `form:"status,omitempty" json:"status,omitempty"`
}

// GetShortagesV1Params defines parameters for GetShortagesV1.
type GetShortagesV1Params struct {
	// Offset Смещение с которого необходимо получить списания
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Количество возвращаемых списаний
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// AuthUserJSONBody defines parameters for AuthUser.
type AuthUserJSONBody struct {
	Code        int    `json:"code"`
	PhoneNumber string `json:"phone_number"`
	Sticker     string `json:"sticker"`
}

// AuthUserParams defines parameters for AuthUser.
type AuthUserParams struct {
	// XRealIP IP пользователя
	XRealIP string `json:"X-Real-IP"`

	// DeviceId ID устройства пользователя
	DeviceId *string `json:"deviceId,omitempty"`

	// XRequestID ID запроса пользователя для обеспечения идемпотентности
	XRequestID *string `json:"X-Request-ID,omitempty"`

	// DeviceToken Токен устройства для отправки пушей
	DeviceToken *string `json:"deviceToken,omitempty"`

	// DeviceName Название устройства
	DeviceName *string `json:"deviceName,omitempty"`

	// WbApptype Тип приложения клиента, тип устройства для отправки пушей
	WbApptype *string `json:"wb-apptype,omitempty"`

	// WbAppversion Версия приложения клиента
	WbAppversion *string `json:"wb-appversion,omitempty"`

	// XNoSession Если метод нужен только для аутентификации по телефону, без сохранения сессии. deviceId, deviceName, deviceToken и wb-apptype в данном случае указывать не нужно
	XNoSession *bool `json:"X-No-Session,omitempty"`

	// XForwardedHost Токен устройства для отправки пушейИсходный хост, который будет выставляться в поле Domain для Cookie
	XForwardedHost *string `json:"X-Forwarded-Host,omitempty"`

	// XForwardedPath Токен устройства для отправки пушейИсходный путь, который будет выставляться в поле Path для Cookie
	XForwardedPath *string `json:"X-Forwarded-Path,omitempty"`
}

// CreateDisputeV1MultipartRequestBody defines body for CreateDisputeV1 for multipart/form-data ContentType.
type CreateDisputeV1MultipartRequestBody CreateDisputeV1MultipartBody

// CloseDisputeV1JSONRequestBody defines body for CloseDisputeV1 for application/json ContentType.
type CloseDisputeV1JSONRequestBody CloseDisputeV1JSONBody

// CreateMessageV1MultipartRequestBody defines body for CreateMessageV1 for multipart/form-data ContentType.
type CreateMessageV1MultipartRequestBody CreateMessageV1MultipartBody

// CreateRevisionV1MultipartRequestBody defines body for CreateRevisionV1 for multipart/form-data ContentType.
type CreateRevisionV1MultipartRequestBody CreateRevisionV1MultipartBody

// AuthUserJSONRequestBody defines body for AuthUser for application/json ContentType.
type AuthUserJSONRequestBody AuthUserJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Получить спор по dispute_id
	// (GET /api/v1/dispute)
	GetDisputeV1(c *gin.Context, params GetDisputeV1Params)
	// Создание нового спора
	// (POST /api/v1/dispute)
	CreateDisputeV1(c *gin.Context)
	// Закрыть спор по dispute_id
	// (PUT /api/v1/dispute)
	CloseDisputeV1(c *gin.Context)
	// Получить список споров
	// (GET /api/v1/disputes)
	GetDisputesV1(c *gin.Context, params GetDisputesV1Params)
	// Создание нового сообщения
	// (POST /api/v1/message)
	CreateMessageV1(c *gin.Context)
	// Получить список сообщений
	// (GET /api/v1/messages)
	GetMessagesV1(c *gin.Context, params GetMessagesV1Params)
	// Получить список организаций
	// (GET /api/v1/organizations)
	GetOrganizationsV1(c *gin.Context, params GetOrganizationsV1Params)
	// Получить ревизию по revisionId
	// (GET /api/v1/revision)
	GetRevisionV1(c *gin.Context, params GetRevisionV1Params)
	// Создание новой ревизии
	// (POST /api/v1/revision)
	CreateRevisionV1(c *gin.Context)
	// Получить список кореспонденций по revision id
	// (GET /api/v1/revision/correspondences)
	GetCorrespondencesV1(c *gin.Context, params GetCorrespondencesV1Params)
	// Получить список ревизий
	// (GET /api/v1/revisions)
	GetRevisionsV1(c *gin.Context, params GetRevisionsV1Params)
	// Получить список списаний
	// (GET /api/v1/shortages)
	GetShortagesV1(c *gin.Context, params GetShortagesV1Params)
	// Авторизация пользователя
	// (POST /api/v1/token)
	AuthUser(c *gin.Context, params AuthUserParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetDisputeV1 operation middleware
func (siw *ServerInterfaceWrapper) GetDisputeV1(c *gin.Context) {

	var err error

	c.Set(SWCookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDisputeV1Params

	// ------------- Optional query parameter "disputeId" -------------

	err = runtime.BindQueryParameter("form", true, false, "disputeId", c.Request.URL.Query(), &params.DisputeId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter disputeId: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "goodsId" -------------

	err = runtime.BindQueryParameter("form", true, false, "goodsId", c.Request.URL.Query(), &params.GoodsId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter goodsId: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetDisputeV1(c, params)
}

// CreateDisputeV1 operation middleware
func (siw *ServerInterfaceWrapper) CreateDisputeV1(c *gin.Context) {

	c.Set(SWCookieAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateDisputeV1(c)
}

// CloseDisputeV1 operation middleware
func (siw *ServerInterfaceWrapper) CloseDisputeV1(c *gin.Context) {

	c.Set(SWCookieAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CloseDisputeV1(c)
}

// GetDisputesV1 operation middleware
func (siw *ServerInterfaceWrapper) GetDisputesV1(c *gin.Context) {

	var err error

	c.Set(SWCookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDisputesV1Params

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", c.Request.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter offset: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", c.Request.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter status: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetDisputesV1(c, params)
}

// CreateMessageV1 operation middleware
func (siw *ServerInterfaceWrapper) CreateMessageV1(c *gin.Context) {

	c.Set(SWCookieAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateMessageV1(c)
}

// GetMessagesV1 operation middleware
func (siw *ServerInterfaceWrapper) GetMessagesV1(c *gin.Context) {

	var err error

	c.Set(SWCookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetMessagesV1Params

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", c.Request.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter offset: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "disputeId" -------------

	if paramValue := c.Query("disputeId"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument disputeId is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "disputeId", c.Request.URL.Query(), &params.DisputeId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter disputeId: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetMessagesV1(c, params)
}

// GetOrganizationsV1 operation middleware
func (siw *ServerInterfaceWrapper) GetOrganizationsV1(c *gin.Context) {

	var err error

	c.Set(SWCookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetOrganizationsV1Params

	// ------------- Optional query parameter "organizationCode" -------------

	err = runtime.BindQueryParameter("form", true, false, "organizationCode", c.Request.URL.Query(), &params.OrganizationCode)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter organizationCode: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", c.Request.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter offset: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "searchToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "searchToken", c.Request.URL.Query(), &params.SearchToken)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter searchToken: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetOrganizationsV1(c, params)
}

// GetRevisionV1 operation middleware
func (siw *ServerInterfaceWrapper) GetRevisionV1(c *gin.Context) {

	var err error

	c.Set(SWCookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRevisionV1Params

	// ------------- Required query parameter "revisionId" -------------

	if paramValue := c.Query("revisionId"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument revisionId is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "revisionId", c.Request.URL.Query(), &params.RevisionId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter revisionId: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetRevisionV1(c, params)
}

// CreateRevisionV1 operation middleware
func (siw *ServerInterfaceWrapper) CreateRevisionV1(c *gin.Context) {

	c.Set(SWCookieAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateRevisionV1(c)
}

// GetCorrespondencesV1 operation middleware
func (siw *ServerInterfaceWrapper) GetCorrespondencesV1(c *gin.Context) {

	var err error

	c.Set(SWCookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCorrespondencesV1Params

	// ------------- Required query parameter "revision_id" -------------

	if paramValue := c.Query("revision_id"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument revision_id is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "revision_id", c.Request.URL.Query(), &params.RevisionId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter revision_id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", c.Request.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter offset: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetCorrespondencesV1(c, params)
}

// GetRevisionsV1 operation middleware
func (siw *ServerInterfaceWrapper) GetRevisionsV1(c *gin.Context) {

	var err error

	c.Set(SWCookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRevisionsV1Params

	// ------------- Optional query parameter "disputeId" -------------

	err = runtime.BindQueryParameter("form", true, false, "disputeId", c.Request.URL.Query(), &params.DisputeId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter disputeId: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", c.Request.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter offset: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", c.Request.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter status: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetRevisionsV1(c, params)
}

// GetShortagesV1 operation middleware
func (siw *ServerInterfaceWrapper) GetShortagesV1(c *gin.Context) {

	var err error

	c.Set(SWCookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetShortagesV1Params

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", c.Request.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter offset: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetShortagesV1(c, params)
}

// AuthUser operation middleware
func (siw *ServerInterfaceWrapper) AuthUser(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AuthUserParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-Real-IP" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Real-IP")]; found {
		var XRealIP string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Real-IP, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Real-IP", valueList[0], &XRealIP, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Real-IP: %w", err), http.StatusBadRequest)
			return
		}

		params.XRealIP = XRealIP

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Real-IP is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Optional header parameter "deviceId" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("deviceId")]; found {
		var DeviceId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for deviceId, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "deviceId", valueList[0], &DeviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter deviceId: %w", err), http.StatusBadRequest)
			return
		}

		params.DeviceId = &DeviceId

	}

	// ------------- Optional header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Request-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-ID", valueList[0], &XRequestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Request-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XRequestID = &XRequestID

	}

	// ------------- Optional header parameter "deviceToken" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("deviceToken")]; found {
		var DeviceToken string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for deviceToken, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "deviceToken", valueList[0], &DeviceToken, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter deviceToken: %w", err), http.StatusBadRequest)
			return
		}

		params.DeviceToken = &DeviceToken

	}

	// ------------- Optional header parameter "deviceName" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("deviceName")]; found {
		var DeviceName string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for deviceName, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "deviceName", valueList[0], &DeviceName, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter deviceName: %w", err), http.StatusBadRequest)
			return
		}

		params.DeviceName = &DeviceName

	}

	// ------------- Optional header parameter "wb-apptype" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("wb-apptype")]; found {
		var WbApptype string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for wb-apptype, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "wb-apptype", valueList[0], &WbApptype, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter wb-apptype: %w", err), http.StatusBadRequest)
			return
		}

		params.WbApptype = &WbApptype

	}

	// ------------- Optional header parameter "wb-appversion" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("wb-appversion")]; found {
		var WbAppversion string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for wb-appversion, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "wb-appversion", valueList[0], &WbAppversion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter wb-appversion: %w", err), http.StatusBadRequest)
			return
		}

		params.WbAppversion = &WbAppversion

	}

	// ------------- Optional header parameter "X-No-Session" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-No-Session")]; found {
		var XNoSession bool
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-No-Session, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-No-Session", valueList[0], &XNoSession, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-No-Session: %w", err), http.StatusBadRequest)
			return
		}

		params.XNoSession = &XNoSession

	}

	// ------------- Optional header parameter "X-Forwarded-Host" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-Host")]; found {
		var XForwardedHost string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Forwarded-Host, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-Host", valueList[0], &XForwardedHost, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Forwarded-Host: %w", err), http.StatusBadRequest)
			return
		}

		params.XForwardedHost = &XForwardedHost

	}

	// ------------- Optional header parameter "X-Forwarded-Path" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Forwarded-Path")]; found {
		var XForwardedPath string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Forwarded-Path, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Forwarded-Path", valueList[0], &XForwardedPath, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Forwarded-Path: %w", err), http.StatusBadRequest)
			return
		}

		params.XForwardedPath = &XForwardedPath

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.AuthUser(c, params)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/api/v1/dispute", wrapper.GetDisputeV1)
	router.POST(options.BaseURL+"/api/v1/dispute", wrapper.CreateDisputeV1)
	router.PUT(options.BaseURL+"/api/v1/dispute", wrapper.CloseDisputeV1)
	router.GET(options.BaseURL+"/api/v1/disputes", wrapper.GetDisputesV1)
	router.POST(options.BaseURL+"/api/v1/message", wrapper.CreateMessageV1)
	router.GET(options.BaseURL+"/api/v1/messages", wrapper.GetMessagesV1)
	router.GET(options.BaseURL+"/api/v1/organizations", wrapper.GetOrganizationsV1)
	router.GET(options.BaseURL+"/api/v1/revision", wrapper.GetRevisionV1)
	router.POST(options.BaseURL+"/api/v1/revision", wrapper.CreateRevisionV1)
	router.GET(options.BaseURL+"/api/v1/revision/correspondences", wrapper.GetCorrespondencesV1)
	router.GET(options.BaseURL+"/api/v1/revisions", wrapper.GetRevisionsV1)
	router.GET(options.BaseURL+"/api/v1/shortages", wrapper.GetShortagesV1)
	router.POST(options.BaseURL+"/api/v1/token", wrapper.AuthUser)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
